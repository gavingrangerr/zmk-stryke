#include <zephyr/kernel.h>
#include <zmk/display/status_screen.h>
#include <zmk/events/layer_state_changed.h>
#include <zmk/events/position_state_changed.h>
#include <zmk/hid.h>
#include <zmk/keymap.h>
#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define MAX_LAYERS 5
#define MAX_POSITIONS 12

static lv_obj_t *screen = NULL;
static lv_obj_t *key_label = NULL;
static lv_obj_t *canvas = NULL;

static uint8_t current_layer = 0;
static char last_key_text[32] = "---";
static int64_t last_key_time = 0;

// Org_v01 font - only numbers and colon (same as Arduino code)
static const uint8_t Org_NumbersBitmaps[] = {
    0xFC, 0x63, 0x1F, 0x80,  // 0x30 '0'
    0xF8,                    // 0x31 '1' (1 byte wide)
    0xF8, 0x7F, 0x0F, 0x80,  // 0x32 '2'
    0xF8, 0x7E, 0x1F, 0x80,  // 0x33 '3'
    0x8C, 0x7E, 0x10, 0x80,  // 0x34 '4'
    0xFC, 0x3E, 0x1F, 0x80,  // 0x35 '5'
    0xFC, 0x3F, 0x1F, 0x80,  // 0x36 '6'
    0xF8, 0x42, 0x10, 0x80,  // 0x37 '7'
    0xFC, 0x7F, 0x1F, 0x80,  // 0x38 '8'
    0xFC, 0x7E, 0x1F, 0x80,  // 0x39 '9'
    0x90,                    // 0x3A ':' (1 byte wide)
};

// Character metrics for custom font
typedef struct {
    uint8_t x_offset;
    uint8_t y_offset;
    uint8_t width;
    uint8_t height;
    uint8_t advance;
} FontChar;

static const FontChar Org_NumbersGlyphs[] = {
    {0, 0, 5, 5, 6},    // '0'
    {4, 0, 1, 5, 2},    // '1'
    {5, 0, 5, 5, 6},    // '2'
    {9, 0, 5, 5, 6},    // '3'
    {13, 0, 5, 5, 6},   // '4'
    {17, 0, 5, 5, 6},   // '5'
    {21, 0, 5, 5, 6},   // '6'
    {25, 0, 5, 5, 6},   // '7'
    {29, 0, 5, 5, 6},   // '8'
    {33, 0, 5, 5, 6},   // '9'
    {37, 1, 1, 4, 2},   // ':'
};

// The bitmap from Arduino code (128x64)
static const unsigned char epd_bitmap_Untitled_design [] = {
    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 
    0x21, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 
    0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x40, 0x7f, 0xfe, 
    0x08, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xff, 0xfe, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1f, 0xff, 0xfc, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0xff, 0xf0, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x7f, 0xfe, 0x00, 
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 
    0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 
    0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 
    0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
    0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
    0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 
    0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
    0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 
    0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 
    0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 
    0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 
    0xff, 0xff, 0xff, 0xfc, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x3f, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xfe, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x7f, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff
};

// Key names for each layer (same as original)
static const char* key_names[MAX_LAYERS][MAX_POSITIONS] = {
    {
        "CMD+C",        "CMD+V",        "CMD+X",        "CMD+Z",
        "CMD+A",        "CMD+S",        "SIGNOUT",      "EMAIL",
        "CMD+SHFT+3",   "CMD+SHFT+4",   "Bootloader",   "KiCad"
    },
    {
        "R",            "M",            "G",            "DEL",
        "V",            "E",            "X",            "W",
        "B",            "F",            "H",            "Fusion"
    },
    {
        "Cmd+K",        "R",            "L",            "D",
        "E",            "Q",            "F",            "CMD+Z",
        "CMD+1",        "CMD+2",        "CMD+0",        "VS Code"
    },
    {
        "Cmd+P",        "CMD+SHFT+P",   "CMD+B",        "CMD+FSLH",
        "CMD+D",        "CMD+SHFT+L",   "CMD+F",        "CMD+Z",
        "CMD+SQRT",     "CMD+SHFT+F",   "CMD+SHFT+E",   "Arduino"
    },
    {
        "CMD+R",        "CMD+U",        "CMD+SHFT+M",   "CMD+K",
        "CMD+T",        "CMD+Z",        "CMD+L",        "CMD+S",
        "BT Clear",     "BT Next",      "Reset",        "Base"
    }
};

// Draw a character using the custom font
static void draw_custom_char(lv_obj_t *canvas_obj, uint8_t c, int x, int y, lv_color_t color) {
    if (c < '0' || (c > '9' && c != ':')) {
        return; // Only draw numbers and colon
    }
    
    int index;
    if (c >= '0' && c <= '9') {
        index = c - '0';
    } else if (c == ':') {
        index = 10;
    } else {
        return;
    }
    
    const FontChar *glyph = &Org_NumbersGlyphs[index];
    const uint8_t *bitmap = &Org_NumbersBitmaps[glyph->x_offset];
    
    for (uint8_t row = 0; row < glyph->height; row++) {
        uint8_t byte = pgm_read_byte(bitmap);
        bitmap++;
        
        for (uint8_t col = 0; col < glyph->width; col++) {
            if (byte & (0x80 >> col)) {
                lv_canvas_set_px(canvas_obj, x + col, y + row, color);
            }
        }
    }
}

// Draw the time using custom font
static void draw_time(lv_obj_t *canvas_obj, int x, int y, lv_color_t color) {
    // Get current system time
    int64_t uptime_ms = k_uptime_get();
    
    // Calculate EST (UTC-5) - Note: This doesn't account for DST
    int64_t est_seconds = (uptime_ms / 1000) - (5 * 3600);
    int hours_24 = (est_seconds / 3600) % 24;
    int minutes = (est_seconds % 3600) / 60;
    
    // Convert to 12-hour format
    int hours = hours_24 % 12;
    if (hours == 0) hours = 12;
    
    // Create time string
    char time_str[6];
    snprintf(time_str, sizeof(time_str), "%02d:%02d", hours, minutes);
    
    // Draw each character
    for (int i = 0; i < 5; i++) {
        draw_custom_char(canvas_obj, time_str[i], x + (i * 7), y, color);
    }
}

// Draw the bitmap background
static void draw_bitmap(lv_obj_t *canvas_obj) {
    lv_canvas_fill_bg(canvas_obj, lv_color_black(), LV_OPA_COVER);
    
    // Draw the bitmap pixel by pixel
    for (int y = 0; y < SCREEN_HEIGHT; y++) {
        for (int x = 0; x < SCREEN_WIDTH; x++) {
            int byte_index = (y * (SCREEN_WIDTH / 8)) + (x / 8);
            uint8_t byte = pgm_read_byte(&epd_bitmap_Untitled_design[byte_index]);
            
            if (byte & (0x80 >> (x % 8))) {
                lv_canvas_set_px(canvas_obj, x, y, lv_color_white());
            }
        }
    }
}

static void update_key_display(void) {
    if (key_label == NULL) return;
    
    lv_label_set_text(key_label, last_key_text);
    
    // Check if key press is recent (within 200ms)
    int64_t now = k_uptime_get();
    bool fresh_press = (now - last_key_time) < 200;
    
    // Update style based on recency
    if (fresh_press) {
        lv_obj_set_style_text_color(key_label, lv_color_black(), LV_PART_MAIN);
        lv_obj_set_style_bg_color(key_label, lv_color_white(), LV_PART_MAIN);
        lv_obj_set_style_bg_opa(key_label, LV_OPA_COVER, LV_PART_MAIN);
        lv_obj_set_style_pad_hor(key_label, 4, LV_PART_MAIN);
        lv_obj_set_style_pad_ver(key_label, 2, LV_PART_MAIN);
        lv_obj_set_style_radius(key_label, 3, LV_PART_MAIN);
    } else {
        lv_obj_set_style_text_color(key_label, lv_color_white(), LV_PART_MAIN);
        lv_obj_set_style_bg_opa(key_label, LV_OPA_TRANSP, LV_PART_MAIN);
    }
    
    // Auto-adjust font size based on text length
    int text_len = strlen(last_key_text);
    const lv_font_t* font;
    if (text_len <= 4) {
        font = &lv_font_montserrat_16;
    } else if (text_len <= 8) {
        font = &lv_font_montserrat_12;
    } else {
        font = &lv_font_montserrat_10;
    }
    lv_obj_set_style_text_font(key_label, font, LV_PART_MAIN);
    
    // Center the label
    lv_obj_center(key_label);
    
    lv_obj_invalidate(key_label);
}

static const char* get_key_name_by_position(uint8_t layer, uint8_t position) {
    if (layer >= MAX_LAYERS || position >= MAX_POSITIONS) {
        return NULL;
    }
    return key_names[layer][position];
}

static void create_ui(void) {
    if (screen == NULL) return;
    
    lv_obj_clean(screen);
    lv_obj_set_style_bg_color(screen, lv_color_black(), LV_PART_MAIN);
    lv_obj_set_style_bg_opa(screen, LV_OPA_COVER, LV_PART_MAIN);
    
    // Create canvas for bitmap background and time
    canvas = lv_canvas_create(screen);
    lv_obj_set_size(canvas, SCREEN_WIDTH, SCREEN_HEIGHT);
    lv_obj_set_pos(canvas, 0, 0);
    
    // Draw background bitmap
    draw_bitmap(canvas);
    
    // Draw time at position 53, 60 (same as Arduino code)
    draw_time(canvas, 53, 60, lv_color_white());
    
    // Key label (transparent background, positioned near bottom)
    key_label = lv_label_create(screen);
    lv_label_set_text(key_label, last_key_text);
    lv_obj_set_style_text_color(key_label, lv_color_white(), LV_PART_MAIN);
    lv_obj_set_style_text_font(key_label, &lv_font_montserrat_16, LV_PART_MAIN);
    lv_obj_set_pos(key_label, 10, SCREEN_HEIGHT - 30);
    
    update_key_display();
}

static void animation_timer_cb(lv_timer_t* timer) {
    // Redraw time on canvas
    if (canvas != NULL) {
        // Clear only the time area (53,60 to 88,65) and redraw
        for (int y = 60; y < 65; y++) {
            for (int x = 53; x < 88; x++) {
                // Check if pixel is part of the background bitmap
                int byte_index = (y * (SCREEN_WIDTH / 8)) + (x / 8);
                uint8_t byte = pgm_read_byte(&epd_bitmap_Untitled_design[byte_index]);
                
                if (byte & (0x80 >> (x % 8))) {
                    lv_canvas_set_px(canvas, x, y, lv_color_white());
                } else {
                    lv_canvas_set_px(canvas, x, y, lv_color_black());
                }
            }
        }
        draw_time(canvas, 53, 60, lv_color_white());
    }
    
    update_key_display();
}

static int layer_state_changed_cb(const zmk_event_t *eh) {
    const struct zmk_layer_state_changed *ev = as_zmk_layer_state_changed(eh);
    if (ev == NULL) return 0;
    
    current_layer = zmk_keymap_highest_layer_active();
    if (current_layer > 4) current_layer = 4;
    
    return 0;
}

static int position_state_changed_cb(const zmk_event_t *eh) {
    const struct zmk_position_state_changed *ev = as_zmk_position_state_changed(eh);
    if (ev == NULL) return 0;
    
    uint8_t position = ev->position;
    bool pressed = ev->state;
    
    if (pressed) {
        const char* key_name = get_key_name_by_position(current_layer, position);
        
        if (key_name != NULL) {
            strncpy(last_key_text, key_name, sizeof(last_key_text) - 1);
            last_key_text[sizeof(last_key_text) - 1] = '\0';
            last_key_time = k_uptime_get();
            update_key_display();
        }
    }
    
    return 0;
}

ZMK_LISTENER(custom_status_layer, layer_state_changed_cb);
ZMK_SUBSCRIPTION(custom_status_layer, zmk_layer_state_changed);

ZMK_LISTENER(custom_status_position, position_state_changed_cb);
ZMK_SUBSCRIPTION(custom_status_position, zmk_position_state_changed);

lv_obj_t *zmk_display_status_screen(void) {
    if (screen == NULL) {
        screen = lv_obj_create(NULL);
        lv_obj_set_size(screen, SCREEN_WIDTH, SCREEN_HEIGHT);
        
        create_ui();
        
        // Create animation timer (50ms refresh)
        lv_timer_create(animation_timer_cb, 50, NULL);
        
        // Initialize current layer
        current_layer = zmk_keymap_highest_layer_active();
        if (current_layer > 4) current_layer = 4;
    }
    
    return screen;
}

#ifdef __cplusplus
}
#endif