#include <zephyr/kernel.h>
#include <zmk/display/status_screen.h>
#include <zmk/events/layer_state_changed.h>
#include <zmk/events/position_state_changed.h>
#include <zmk/hid.h>
#include <zmk/keymap.h>
#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define MAX_TEXT_HEIGHT 16
#define MAX_LAYERS 5
#define MAX_POSITIONS 12

static const unsigned char PROGMEM image__0000_bits[] = {0x7f,0xff,0xff,0xff,0xdb,0x55,0x55,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xff,0xfc,0x79,0xe3,0xcf,0x3f,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xfc,0x70,0xe3,0x86,0x1f,0xff,0xff,0xcc,0xee,0x77,0x38,0x00,0x00,0x00,0xff,0xff,0xfc,0x70,0xe3,0x8e,0x1f,0xff,0xff,0x99,0xcc,0xe6,0x70,0x15,0x55,0x55,0x65,0xff,0xfe,0x79,0xf3,0xcf,0x3f,0xff,0xff,0x33,0xb9,0xdc,0xe0,0x3d,0xdd,0xdd,0x31,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x66,0x33,0x19,0xc0,0x60,0x00,0x00,0x18,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x4f,0xff,0xff,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x9f,0xff,0xfc,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x3f,0xff,0xfc,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x7f,0xff,0xf0,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x07,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x1f,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xf8,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x01,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x01,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xc0,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1c,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1c,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x01,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xc0,0x00,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x00,0x00,0x3e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7c,0x00,0x00,0x0f,0xfa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaf,0xf8,0x00,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x3f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

static lv_obj_t *screen = NULL;
static lv_obj_t *key_label = NULL;
static lv_obj_t *layer_indicators[5];
static lv_obj_t *time_label = NULL;

static uint8_t current_layer = 0;
static char last_key_text[32] = "---";
static int64_t last_key_time = 0;
static char time_str[10] = "00:00";

static const char* key_names[MAX_LAYERS][MAX_POSITIONS] = {
    {
        "CMD+C",        "CMD+V",        "CMD+X",        "CMD+Z",
        "CMD+A",        "CMD+S",        "SIGNOUT",      "EMAIL",
        "CMD+SHFT+3",   "CMD+SHFT+4",   "Bootloader",   "KiCad"
    },
    {
        "R",            "M",            "G",            "DEL",
        "V",            "E",            "X",            "W",
        "B",            "F",            "H",            "Fusion"
    },
    {
        "Cmd+K",        "R",            "L",            "D",
        "E",            "Q",            "F",            "CMD+Z",
        "CMD+1",        "CMD+2",        "CMD+0",        "VS Code"
    },
    {
        "Cmd+P",        "CMD+SHFT+P",   "CMD+B",        "CMD+FSLH",
        "CMD+D",        "CMD+SHFT+L",   "CMD+F",        "CMD+Z",
        "CMD+SQRT",     "CMD+SHFT+F",   "CMD+SHFT+E",   "Arduino"
    },
    {
        "CMD+R",        "CMD+U",        "CMD+SHFT+M",   "CMD+K",
        "CMD+T",        "CMD+Z",        "CMD+L",        "CMD+S",
        "BT Clear",     "BT Next",      "Reset",        "Base"
    }
};

static void update_time_display(void) {
    if (time_label == NULL) return;
    
    // Get current UTC time
    int64_t uptime_ms = k_uptime_get();
    int64_t system_time_ms = uptime_ms + CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    
    // Calculate hours, minutes in 24-hour format
    int total_seconds = (system_time_ms / 1000) % 86400;
    int hours = total_seconds / 3600;
    int minutes = (total_seconds % 3600) / 60;
    
    // Format time string in 24-hour format
    snprintf(time_str, sizeof(time_str), "%02d:%02d", hours, minutes);
    
    lv_label_set_text(time_label, time_str);
}

static const char* get_key_name_by_position(uint8_t layer, uint8_t position) {
    if (layer >= MAX_LAYERS || position >= MAX_POSITIONS) {
        return NULL;
    }
    return key_names[layer][position];
}

static int find_best_text_size(const char* text, int max_width, int max_height) {
    int text_len = strlen(text);
    
    for (int size = 3; size >= 1; size--) {
        int char_width = (size == 3) ? 16 : (size == 2) ? 12 : 8;
        int char_height = (size == 3) ? 24 : (size == 2) ? 16 : 8;
        
        int text_width = text_len * char_width;
        int text_height = char_height;
        
        if (text_height <= max_height && text_width <= max_width) {
            return size;
        }
    }
    
    return 1;
}

static const lv_font_t* get_font_for_size(int size) {
    if (size >= 3) {
        return &lv_font_montserrat_20;
    } else if (size == 2) {
        return &lv_font_montserrat_16;
    } else {
        return &lv_font_montserrat_10;
    }
}

static void update_key_display(void) {
    if (key_label == NULL) return;
    
    lv_label_set_text(key_label, last_key_text);
    
    // Position the key label in the center of the screen where the bitmap shows it
    int best_size = find_best_text_size(last_key_text, 116, MAX_TEXT_HEIGHT);
    const lv_font_t* font = get_font_for_size(best_size);
    lv_obj_set_style_text_font(key_label, font, LV_PART_MAIN);
    
    int64_t now = k_uptime_get();
    bool fresh_press = (now - last_key_time) < 200;
    
    if (fresh_press) {
        // Invert colors for fresh presses (white text on black background in the bitmap)
        lv_obj_set_style_text_color(key_label, lv_color_black(), LV_PART_MAIN);
    } else {
        // Normal display (black text on white background in the bitmap)
        lv_obj_set_style_text_color(key_label, lv_color_white(), LV_PART_MAIN);
    }
    
    // Center the label in the area shown in the bitmap (approx 5, 60 position)
    lv_obj_set_pos(key_label, 5, 60);
    
    lv_obj_invalidate(key_label);
    lv_obj_invalidate(screen);
}

static void update_layer_indicators(void) {
    // Create layer indicators that match the style shown in your bitmap
    // The bitmap shows them in a row along the bottom
    for (int i = 0; i < 5; i++) {
        if (layer_indicators[i] == NULL) continue;
        
        lv_obj_t* label = lv_obj_get_child(layer_indicators[i], 0);
        
        if (i == current_layer) {
            // Active layer - white background, black text (inverted in bitmap)
            lv_obj_set_style_bg_color(layer_indicators[i], lv_color_white(), LV_PART_MAIN);
            lv_obj_set_style_bg_opa(layer_indicators[i], LV_OPA_COVER, LV_PART_MAIN);
            lv_obj_set_style_border_color(layer_indicators[i], lv_color_white(), LV_PART_MAIN);
            lv_obj_set_style_text_color(label, lv_color_black(), LV_PART_MAIN);
        } else {
            // Inactive layer - transparent with white border and text
            lv_obj_set_style_bg_opa(layer_indicators[i], LV_OPA_TRANSP, LV_PART_MAIN);
            lv_obj_set_style_border_color(layer_indicators[i], lv_color_white(), LV_PART_MAIN);
            lv_obj_set_style_text_color(label, lv_color_white(), LV_PART_MAIN);
        }
    }
}

static void create_ui(void) {
    if (screen == NULL) return;
    
    lv_obj_clean(screen);
    
    // Set black background (matches bitmap)
    lv_obj_set_style_bg_color(screen, lv_color_black(), LV_PART_MAIN);
    lv_obj_set_style_bg_opa(screen, LV_OPA_COVER, LV_PART_MAIN);
    
    // Create the main bitmap background
    lv_obj_t *bitmap = lv_canvas_create(screen);
    lv_obj_set_size(bitmap, SCREEN_WIDTH, SCREEN_HEIGHT);
    lv_obj_set_pos(bitmap, 0, 0);
    
    // Note: LVGL doesn't directly support PROGMEM bitmap display from C arrays
    // In a real implementation, you'd need to convert the bitmap to an LVGL image
    // For now, we'll create the UI elements to match the positions in your bitmap
    
    // Time display at position shown in bitmap (00:00 at 5, 60)
    time_label = lv_label_create(screen);
    update_time_display();
    lv_obj_set_style_text_color(time_label, lv_color_white(), LV_PART_MAIN);
    lv_obj_set_style_text_font(time_label, &lv_font_montserrat_16, LV_PART_MAIN);
    lv_obj_set_pos(time_label, 5, 60);
    
    // Key press display (overlay on the bitmap at the same position as 00:00)
    key_label = lv_label_create(screen);
    lv_label_set_text(key_label, last_key_text);
    lv_obj_set_style_text_color(key_label, lv_color_white(), LV_PART_MAIN);
    lv_obj_set_style_text_font(key_label, &lv_font_montserrat_16, LV_PART_MAIN);
    lv_obj_set_pos(key_label, 5, 60);
    
    // Create layer indicators along the bottom (position them like in bitmap)
    int indicator_y = 52;  // Position from your bitmap
    int indicator_spacing = 25;
    int start_x = 36;  // Start position from your bitmap
    
    for (int i = 0; i < 5; i++) {
        int x = start_x + (i * indicator_spacing);
        
        layer_indicators[i] = lv_obj_create(screen);
        lv_obj_set_size(layer_indicators[i], 20, 12);
        lv_obj_set_pos(layer_indicators[i], x, indicator_y);
        lv_obj_set_style_radius(layer_indicators[i], 2, LV_PART_MAIN);
        lv_obj_set_style_border_color(layer_indicators[i], lv_color_white(), LV_PART_MAIN);
        lv_obj_set_style_border_width(layer_indicators[i], 1, LV_PART_MAIN);
        lv_obj_set_style_pad_all(layer_indicators[i], 0, LV_PART_MAIN);
        
        lv_obj_t* label = lv_label_create(layer_indicators[i]);
        char layer_text[4];
        snprintf(layer_text, sizeof(layer_text), "L%d", i);
        lv_label_set_text(label, layer_text);
        lv_obj_set_style_text_font(label, &lv_font_montserrat_10, LV_PART_MAIN);
        lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);
    }
    
    update_layer_indicators();
    update_key_display();
}

static void animation_timer_cb(lv_timer_t* timer) {
    update_key_display();
    update_time_display();
}

static int layer_state_changed_cb(const zmk_event_t *eh) {
    const struct zmk_layer_state_changed *ev = as_zmk_layer_state_changed(eh);
    if (ev == NULL) return 0;
    
    current_layer = zmk_keymap_highest_layer_active();
    if (current_layer > 4) current_layer = 4;
    
    update_layer_indicators();
    
    return 0;
}

static int position_state_changed_cb(const zmk_event_t *eh) {
    const struct zmk_position_state_changed *ev = as_zmk_position_state_changed(eh);
    if (ev == NULL) return 0;
    
    uint8_t position = ev->position;
    bool pressed = ev->state;
    
    if (pressed) {
        const char* key_name = get_key_name_by_position(current_layer, position);
        
        if (key_name != NULL) {
            strncpy(last_key_text, key_name, sizeof(last_key_text) - 1);
            last_key_text[sizeof(last_key_text) - 1] = '\0';
            last_key_time = k_uptime_get();
            update_key_display();
            
            // Briefly show the key name, then revert to time display
            lv_label_set_text(time_label, last_key_text);
            lv_timer_t* revert_timer = lv_timer_create_basic();
            lv_timer_set_cb(revert_timer, [](lv_timer_t* timer) {
                update_time_display();
                lv_timer_del(timer);
            });
            lv_timer_set_repeat_count(revert_timer, 1);
            lv_timer_set_period(revert_timer, 1000);  // Show key for 1 second
        }
    }
    
    return 0;
}

ZMK_LISTENER(custom_status_layer, layer_state_changed_cb);
ZMK_SUBSCRIPTION(custom_status_layer, zmk_layer_state_changed);

ZMK_LISTENER(custom_status_position, position_state_changed_cb);
ZMK_SUBSCRIPTION(custom_status_position, zmk_position_state_changed);

lv_obj_t *zmk_display_status_screen(void) {
    if (screen == NULL) {
        screen = lv_obj_create(NULL);
        lv_obj_set_size(screen, SCREEN_WIDTH, SCREEN_HEIGHT);
        
        create_ui();
        
        // Create animation timer
        lv_timer_create(animation_timer_cb, 100, NULL);
        
        // Initialize current layer
        current_layer = zmk_keymap_highest_layer_active();
        if (current_layer > 4) current_layer = 4;
        update_layer_indicators();
    }
    
    return screen;
}

#ifdef __cplusplus
}
#endif