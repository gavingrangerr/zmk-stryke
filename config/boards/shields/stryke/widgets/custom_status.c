#include <zephyr/kernel.h>
#include <zmk/display/status_screen.h>
#include <zmk/events/layer_state_changed.h>
#include <zmk/events/position_state_changed.h>
#include <zmk/hid.h>
#include <zmk/keymap.h>
#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define MAX_LAYERS 5
#define MAX_POSITIONS 12

// Bitmap data from Arduino sketch
static const uint8_t epd_bitmap_Untitled_design[] = {
    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 
    0x21, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 
    0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x40, 0x7f, 0xfe, 
    0x08, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xff, 0xfe, 
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1f, 0xff, 0xfc, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3f, 0xff, 0xf0, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x7f, 0xfe, 0x00, 
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 
    0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 
    0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 
    0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
    0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
    0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 
    0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
    0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 
    0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 
    0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 
    0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 
    0xff, 0xff, 0xff, 0xfc, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x3f, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xfe, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x7f, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff
};

// Org_01 Font Data (hardcoded for numbers and colon)
// Bitmap data for '0'-'9' and ':'
static const uint8_t org_01_bitmaps[] = {
    // '0' (0x30)
    0xFC, 0x63, 0x1F, 0x80,
    // '1' (0x31)
    0xF8,
    // '2' (0x32)
    0xF8, 0x7F, 0x0F, 0x80,
    // '3' (0x33)
    0xF8, 0x7E, 0x1F, 0x80,
    // '4' (0x34)
    0x8C, 0x7E, 0x10, 0x80,
    // '5' (0x35)
    0xFC, 0x3E, 0x1F, 0x80,
    // '6' (0x36)
    0xFC, 0x3F, 0x1F, 0x80,
    // '7' (0x37)
    0xF8, 0x42, 0x10, 0x80,
    // '8' (0x38)
    0xFC, 0x7F, 0x1F, 0x80,
    // '9' (0x39)
    0xFC, 0x7E, 0x1F, 0x80,
    // ':' (0x3A)
    0x90
};

static lv_obj_t *screen = NULL;
static lv_obj_t *canvas = NULL;
static lv_obj_t *key_label = NULL;
static lv_obj_t *time_label = NULL;

static uint8_t current_layer = 0;
static char last_key_text[32] = "---";
static int64_t last_key_time = 0;
static char time_str[10] = "00:00";

static const char* key_names[MAX_LAYERS][MAX_POSITIONS] = {
    {
        "CMD+C",        "CMD+V",        "CMD+X",        "CMD+Z",
        "CMD+A",        "CMD+S",        "SIGNOUT",      "EMAIL",
        "CMD+SHFT+3",   "CMD+SHFT+4",   "Bootloader",   "KiCad"
    },
    {
        "R",            "M",            "G",            "DEL",
        "V",            "E",            "X",            "W",
        "B",            "F",            "H",            "Fusion"
    },
    {
        "Cmd+K",        "R",            "L",            "D",
        "E",            "Q",            "F",            "CMD+Z",
        "CMD+1",        "CMD+2",        "CMD+0",        "VS Code"
    },
    {
        "Cmd+P",        "CMD+SHFT+P",   "CMD+B",        "CMD+FSLH",
        "CMD+D",        "CMD+SHFT+L",   "CMD+F",        "CMD+Z",
        "CMD+SQRT",     "CMD+SHFT+F",   "CMD+SHFT+E",   "Arduino"
    },
    {
        "CMD+R",        "CMD+U",        "CMD+SHFT+M",   "CMD+K",
        "CMD+T",        "CMD+Z",        "CMD+L",        "CMD+S",
        "BT Clear",     "BT Next",      "Reset",        "Base"
    }
};

// Draw a single character from Org_01 font at given position
static void draw_org_char(lv_obj_t *canvas_obj, char c, int16_t x, int16_t y) {
    lv_draw_rect_dsc_t rect_dsc;
    lv_draw_rect_dsc_init(&rect_dsc);
    rect_dsc.bg_color = lv_color_white();
    rect_dsc.bg_opa = LV_OPA_COVER;
    
    int char_index = -1;
    const uint8_t* bitmap_data = NULL;
    int byte_offset = 0;
    
    // Map character to bitmap data
    if (c >= '0' && c <= '9') {
        char_index = c - '0';
        byte_offset = 0;
        for (int i = 0; i < char_index; i++) {
            if (i == 1) byte_offset += 1; // '1' is 1 byte
            else byte_offset += 3; // Others are 3 bytes (5 bits * 5 rows = 25 bits = ~3 bytes)
        }
    } else if (c == ':') {
        byte_offset = 30; // After all digits
    } else {
        return; // Unsupported character
    }
    
    bitmap_data = &org_01_bitmaps[byte_offset];
    
    // Character dimensions (from Org_01 font)
    int width = (c == '1') ? 1 : 5;
    int height = 5;
    
    // Draw the character pixel by pixel
    int bit_index = 0;
    for (int row = 0; row < height; row++) {
        for (int col = 0; col < width; col++) {
            int byte_idx = bit_index / 8;
            int bit_pos = 7 - (bit_index % 8);
            
            if (bitmap_data[byte_idx] & (1 << bit_pos)) {
                lv_area_t area;
                area.x1 = x + col;
                area.y1 = y + row;
                area.x2 = x + col;
                area.y2 = y + row;
                
                lv_canvas_draw_rect(canvas_obj, &area, &rect_dsc);
            }
            
            bit_index++;
        }
    }
}

// Draw time string using Org_01 font
static void draw_time_org(lv_obj_t *canvas_obj, const char* time_str, int16_t x, int16_t y) {
    int cursor_x = x;
    
    for (int i = 0; time_str[i] != '\0'; i++) {
        draw_org_char(canvas_obj, time_str[i], cursor_x, y);
        
        // Advance cursor (with spacing)
        if (time_str[i] == '1') {
            cursor_x += 2; // '1' is narrower
        } else if (time_str[i] == ':') {
            cursor_x += 2;
        } else {
            cursor_x += 6; // 5 pixels + 1 spacing
        }
    }
}

static void update_time_display(void) {
    // Get current time (simplified - you may need to implement actual time tracking)
    int64_t uptime_ms = k_uptime_get();
    
    // Convert to Eastern Standard Time (UTC-5) - simplified calculation
    int64_t est_ms = uptime_ms - (5 * 3600 * 1000);
    
    int total_seconds = (est_ms / 1000) % 86400;
    int hours = (total_seconds / 3600) % 24;
    int minutes = (total_seconds % 3600) / 60;
    
    // Format as HH:MM (24-hour format to match Arduino)
    snprintf(time_str, sizeof(time_str), "%02d:%02d", hours, minutes);
}

static const char* get_key_name_by_position(uint8_t layer, uint8_t position) {
    if (layer >= MAX_LAYERS || position >= MAX_POSITIONS) {
        return NULL;
    }
    return key_names[layer][position];
}

static void draw_display(void) {
    if (canvas == NULL) return;
    
    // Clear canvas
    lv_canvas_fill_bg(canvas, lv_color_black(), LV_OPA_COVER);
    
    // Draw bitmap background
    lv_draw_img_dsc_t img_dsc;
    lv_draw_img_dsc_init(&img_dsc);
    img_dsc.recolor_opa = LV_OPA_TRANSP;
    
    lv_img_dsc_t img;
    img.header.always_zero = 0;
    img.header.w = 128;
    img.header.h = 64;
    img.header.cf = LV_IMG_CF_INDEXED_1BIT;
    img.data = epd_bitmap_Untitled_design;
    img.data_size = sizeof(epd_bitmap_Untitled_design);
    
    lv_area_t coords = {0, 0, 127, 63};
    lv_canvas_draw_img(canvas, &coords, &img, &img_dsc);
    
    // Update and draw time using Org_01 font at position (53, 55) to match Arduino
    update_time_display();
    draw_time_org(canvas, time_str, 53, 55);
    
    // Update keypress display
    if (key_label != NULL) {
        lv_label_set_text(key_label, last_key_text);
        
        // Flash effect for fresh keypresses
        int64_t now = k_uptime_get();
        bool fresh_press = (now - last_key_time) < 200;
        
        if (fresh_press) {
            lv_obj_set_style_text_color(key_label, lv_color_black(), LV_PART_MAIN);
            lv_obj_set_style_bg_color(key_label, lv_color_white(), LV_PART_MAIN);
            lv_obj_set_style_bg_opa(key_label, LV_OPA_COVER, LV_PART_MAIN);
        } else {
            lv_obj_set_style_text_color(key_label, lv_color_white(), LV_PART_MAIN);
            lv_obj_set_style_bg_opa(key_label, LV_OPA_TRANSP, LV_PART_MAIN);
        }
    }
}

static void create_ui(void) {
    if (screen == NULL) return;
    
    lv_obj_clean(screen);
    
    lv_obj_set_style_bg_color(screen, lv_color_black(), LV_PART_MAIN);
    lv_obj_set_style_bg_opa(screen, LV_OPA_COVER, LV_PART_MAIN);
    
    // Create canvas for bitmap and time
    static lv_color_t cbuf[LV_CANVAS_BUF_SIZE_INDEXED_1BIT(SCREEN_WIDTH, SCREEN_HEIGHT)];
    
    canvas = lv_canvas_create(screen);
    lv_canvas_set_buffer(canvas, cbuf, SCREEN_WIDTH, SCREEN_HEIGHT, LV_IMG_CF_INDEXED_1BIT);
    lv_canvas_set_palette(canvas, 0, lv_color_black());
    lv_canvas_set_palette(canvas, 1, lv_color_white());
    lv_obj_align(canvas, LV_ALIGN_CENTER, 0, 0);
    
    // Create keypress label (centered on screen, overlaid on canvas)
    key_label = lv_label_create(screen);
    lv_label_set_text(key_label, last_key_text);
    lv_obj_set_style_text_color(key_label, lv_color_white(), LV_PART_MAIN);
    lv_obj_set_style_text_font(key_label, &lv_font_montserrat_14, LV_PART_MAIN);
    lv_obj_set_style_bg_opa(key_label, LV_OPA_TRANSP, LV_PART_MAIN);
    lv_obj_align(key_label, LV_ALIGN_CENTER, 0, -5);
    
    draw_display();
}

static void animation_timer_cb(lv_timer_t* timer) {
    draw_display();
}

static int layer_state_changed_cb(const zmk_event_t *eh) {
    const struct zmk_layer_state_changed *ev = as_zmk_layer_state_changed(eh);
    if (ev == NULL) return 0;
    
    current_layer = zmk_keymap_highest_layer_active();
    if (current_layer > 4) current_layer = 4;
    
    return 0;
}

static int position_state_changed_cb(const zmk_event_t *eh) {
    const struct zmk_position_state_changed *ev = as_zmk_position_state_changed(eh);
    if (ev == NULL) return 0;
    
    uint8_t position = ev->position;
    bool pressed = ev->state;
    
    if (pressed) {
        const char* key_name = get_key_name_by_position(current_layer, position);
        
        if (key_name != NULL) {
            strncpy(last_key_text, key_name, sizeof(last_key_text) - 1);
            last_key_text[sizeof(last_key_text) - 1] = '\0';
            last_key_time = k_uptime_get();
            draw_display();
        }
    }
    
    return 0;
}

ZMK_LISTENER(custom_status_layer, layer_state_changed_cb);
ZMK_SUBSCRIPTION(custom_status_layer, zmk_layer_state_changed);

ZMK_LISTENER(custom_status_position, position_state_changed_cb);
ZMK_SUBSCRIPTION(custom_status_position, zmk_position_state_changed);

lv_obj_t *zmk_display_status_screen(void) {
    if (screen == NULL) {
        screen = lv_obj_create(NULL);
        lv_obj_set_size(screen, SCREEN_WIDTH, SCREEN_HEIGHT);
        
        create_ui();
        
        // Update display every 50ms
        lv_timer_create(animation_timer_cb, 50, NULL);
        
        current_layer = zmk_keymap_highest_layer_active();
        if (current_layer > 4) current_layer = 4;
    }
    
    return screen;
}

#ifdef __cplusplus
}
#endif